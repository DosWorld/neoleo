@node Keymaps, Functions, Programs, Top
@chapter Keymaps and defining keys

What a key does when it is pressed depends on the context.  The listing
of actions associated with a key in a given context is called a
'keymap'.  Keymaps may have a 'default map'.  If a key is pressed which
does not have an assigned meaning in that map, the map's default map is
checked, and that map's default map, until a command is found or there
are no more default maps to scan.

The different keymaps, and their usage are as follows:

@example
  universal         The root of all keymaps.
  main              The default keymap.
  meta              Default @key{ESC} commands.
  ansi              ANSI arrow keys.
  trolx             Default @key{C-x} commands.
  generic-*         More generic versions of the above, work everywhere.
  mouse             Bindings for mouse buttons.
  prefix            Number keys, and -, for argument prefix.
  help              Various levels of help commands.
@end example

The diagram below shows the relationship between the various keymaps.
The keymap to the left of a given keymap is its default.

@example
                  | generic-main ----| main
                  |                  | read-string ---| read-<item>*
		  |
                  | generic-meta ----| meta
                  |                  | meta-read-string --- meta-read-formula
		  |
                  | generic-ansi ----| ansi
                  |                  | edit-ansi
		  |
                  | generic-trolx ---| trolx
                  |                  | trolx-read-string
  universal ------| mouse
                  | generic-menu
                  | prefix
                  | meta-edit-ansi
                  | read-keyseq
                  | set-auto-motion
                  | read-most-chars ---| read-char
                  |                    | read-menu
                  | press-any
                  | view-info
                  | set-*-attr  (cell, region, default)
                  | generic-help ---| unprompted-help
                                    | help
                                    | verbose-help
@end example

@table @code
@item M-x bind-key  
This asks for the name of a keymap followed by a
command name and a key to bind it to.  If the 'command' you
give is a cell or region in the spreadsheet, it is taken as a
macro, and bound to the key you specify.  For example, to make @key{C-1}
move up one cell in the main keymap, type
@cmindex bind-key

@example
        @key{M-x} bind-key @key{RET} main @key{RET} up-cell @key{C-1} @key{RET}
@end example

@item M-x unbind-key
@cmindex unbind-key
This asks for the name of a keymap and the key in that map to unbind.
For example, to remove the default mapping bound to @kbd{M-k}, type
@example
	@key{M-k} unbind-key @key{RET} meta @key{RET} @key{k}
@end example

@item  M-x describe-key 
@cmindex describe-key
Have the user press a key, and then describe
what function that key is bound to. (bound to @kbd{C-h c})
@kindex C-h c

@item M-x write-keys    
@cmindex write-keys
Write a list o@code{f commands} to a file that, when
executed with read-commands, will return the keymaps to their
current state.  To write a list of commands to the file
@file{/tmp/name}, type

@example
        @kbd{M-x} write-keys @key{RET} /tmp/name @key{RET}
@end example

@item M-x read-commands	
This command opens the file you specify, reads in each
line, and executes them as if you'd typed them in to
execute-command.  If any command needs more arguments than are
included on the line, it will prompt you (interactively) for
the missing information.


@end table



@section Editing cells

When you edit the contents of a cell, @code{neoleo} activates the
@code{edit-ansi} key bindings.  Prior to 18-Aug-2017, the HOME and
END keys did not work unless you added to the following to 
@code{~/.oleorc}:

@example
bind-key edit-ansi end-of-line F
bind-key edit-ansi beginning-of-line H
@end example

Here, F is the END key, and H is the HOME key. These values have
been added to @code{init.cc} as part of the commit to issue#21,
so the HOME and END keys should now work seamlessly when editing
cells.

@section Special keys (home, delete, etc.)

Prior to commit of ISS#22, the home, end and delete keys did not 
work well, or at all. There are two main factors at play here:

@itemize @bullet
@item
the way that @code{terminfo} generates key sequences

@item
the way that @code{neoleo} handles them, and what it expects
@end itemize


You can find out the keys that are being generated by
going to the shell, typing the UNIX command @code{read}, followed
by the key presses. @code{return} quits the command. For example,
on my terminal, The @code{Home} key generates the sequence @code{^[[1~}.
You can also use @code{showkey -a} to achieve something similar. The 
problem is that @code{neoleo} expected to see @code{^[H}.

To fix this, ISS#22 reinterprets inputs of the form @code{^[?N~}, where
`?' is any character, and N is one of 1, 3, or 4; corresponding to the home,
delete and end key respectively. It then substitutes the value H for 1, F 
for 4, and leaves 3 unchanged. @footnote{The translation occurs in 
@code{io-curses.cc:_io_read_kbd()}, duly annotated.} It also ignores the 
trailing ~. It then processes the buffet as it did before.

Here is what @code{neoleo} expects to see, against what is usually given,
and the usual interpretation of the sequence:
@multitable {12345} {123456} {---------------------}
@headitem Expect @tab Given @tab Meaning
@item @code{\E[3} @tab @code{\E[3~} @tab Delete key
@item @code{\E[A} @tab @code{\E[A}  @tab Arrow up
@item @code{\E[B} @tab @code{\E[B}  @tab Arrow down
@item @code{\E[C} @tab @code{\E[C}  @tab Arrow right
@item @code{\E[D} @tab @code{\E[D}  @tab Arrow left
@item @code{\E[F} @tab @code{\E[4~} @tab End key
@item @code{\E[H} @tab @code{\E[1~} @tab Home key
@end multitable

In the table, @code{\E} is synonymous with @code{\e} and @code{^[};
 so for example
@code{^[[H} and @code{\E[H]} mean the same thing. Also worth noting
is that @code{\E} is octal @code{\033}. You will notice that the
arrow keys are identical between what is expected, and what is given.
They have been included for reference purposes.

By `usually', it is meant that it is the sequence that the terminal
typically generates; but is not guaranteed. You can find out what is 
actualy generated (barring some potential mismatches) by consulting
@code{terminfo} @footnote{@code{terminfo} is the terminal capability
database. Arch Linux has a wiki 
@uref{https://wiki.archlinux.org/index.php/Home_and_End_keys_not_working, page}
explaining the use of @code{infocmp} to interrogate the terminal's 
structure. A discussion on this topic is also on an Arch Forum
@uref{https://bbs.archlinux.org/viewtopic.php?id=229196, thread}
(included here for archival purposes).
}.

In order to bind a key, you need to use the last letter expected, and
@code{neoleo} will apply it correctly (barring terminal wonks). The
section `Editing cells' gives some examples, reproduced below:
@example
bind-key edit-ansi end-of-line F
bind-key edit-ansi beginning-of-line H
@end example
